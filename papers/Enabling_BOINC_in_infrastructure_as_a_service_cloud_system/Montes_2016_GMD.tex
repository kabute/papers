%% Copernicus Publications Manuscript Preparation Template for LaTeX Submissions
%% ---------------------------------
%% This template should be used for copernicus.cls
%% The class file and some style files are bundled in the Copernicus Latex Package which can be downloaded from the different journal webpages.
%% For further assistance please contact the Copernicus Publications at: publications@copernicus.org
%% http://publications.copernicus.org


%% Please use the following documentclass and Journal Abbreviations for Discussion Papers and Final Revised Papers.


%% 2-Column Papers and Discussion Papers
\documentclass[journal abbreviation, manuscript]{copernicus}



%% Journal Abbreviations (Please use the same for Discussion Papers and Final Revised Papers)

% Archives Animal Breeding (aab)
% Atmospheric Chemistry and Physics (acp)
% Advances in Geosciences (adgeo)
% Advances in Statistical Climatology, Meteorology and Oceanography (ascmo)
% Annales Geophysicae (angeo)
% ASTRA Proceedings (ap)
% Atmospheric Measurement Techniques (amt)
% Advances in Radio Science (ars)
% Advances in Science and Research (asr)
% Biogeosciences (bg)
% Climate of the Past (cp)
% Drinking Water Engineering and Science (dwes)
% Earth System Dynamics (esd)
% Earth Surface Dynamics (esurf)
% Earth System Science Data (essd)
% Fossil Record (fr)
% Geographica Helvetica (gh)
% Geoscientific Instrumentation, Methods and Data Systems (gi)
% Geoscientific Model Development (gmd)
% Geothermal Energy Science (gtes)
% Hydrology and Earth System Sciences (hess)
% History of Geo- and Space Sciences (hgss)
% Journal of Sensors and Sensor Systems (jsss)
% Mechanical Sciences (ms)
% Natural Hazards and Earth System Sciences (nhess)
% Nonlinear Processes in Geophysics (npg)
% Ocean Science (os)
% Proceedings of the International Association of Hydrological Sciences (piahs)
% Primate Biology (pb)
% Scientific Drilling (sd)
% SOIL (soil)
% Solid Earth (se)
% The Cryosphere (tc)
% Web Ecology (we)
% Wind Energy Science (wes)


%% \usepackage commands included in the copernicus.cls:
%\usepackage[german, english]{babel}
%\usepackage{tabularx}
%\usepackage{cancel}
%\usepackage{multirow}
%\usepackage{supertabular}
%\usepackage{algorithmic}
%\usepackage{algorithm}
%\usepackage{amsthm}
%\usepackage{float}
%\usepackage{subfig}
%\usepackage{rotating}
\usepackage{color,soul}

\begin{document}

\title{Enabling BOINC in Infrastructure as a Service Cloud Systems}

% \Author[affil]{given_name}{surname}
\Author[1]{Diego}{Montes}
\Author[1,2]{Juan A.}{A\~nel}
\Author[3]{Tom\'as}{F. Pena}
\Author[4,5]{Peter}{Uhe}
\Author[5]{David}{C. H. Wallom}
%\Author[]{}{}
%\Author[]{}{}
%\Author[]{}{}

\affil[1]{EPhysLab, Universidade de Vigo, Ourense, 32004, Spain}
\affil[2]{Smith School of Enterprise and the Environment, University of Oxford, Oxford, UK}
\affil[3]{Centro de Investigaci\'on en Tecnolox\'ias da Informaci\'on (CITIUS), University of Santiago de Compostela, Santiago de Compostela, 15782, Spain}
\affil[4]{School of Geography and the Environment, University of Oxford, Oxford, UK}
\affil[5]{Oxford e-Research Centre, University of Oxford, OX1 3QG, UK.}

%% The [] brackets identify the author with the corresponding affiliation. 1, 2, 3, etc. should be inserted.

\runningtitle{Enabling BOINC in Cloud Services}

\runningauthor{Diego Montes}

\correspondence{Diego Montes (kabute@uvigo.es)}



\received{}
\pubdiscuss{} %% only important for two-stage journals
\revised{}
\accepted{}
\published{}

%% These dates will be inserted by Copernicus Publications during the typesetting process.


\firstpage{1}

\maketitle



\begin{abstract}
Volunteer or Crowd computing is becoming increasingly popular to solve complex research problems, from an increasing diverse range of areas. The majority of these have been built using the Berkeley Open Infrastructure for Network Computing (BOINC) platform, which provides a range of different services to manage all computation aspects of a project. The BOINC system is ideal in those cases where not only does the research community involved need low cost access to massive computing resource but also that there is a significant public interest in the research done.

We discuss the way in which Cloud services can help BOINC based projects to deliver results in a fast, on demand manner. This is difficult to achieve using volunteers, and at the same time, using scalable cloud resources for short on demand projects can optimize the use of the available resources. We show how this design can be used as an efficient distributed computing platform within the Cloud, and outline new approaches that could open up new possibilities in this field, using climate\textit{prediction}.net as a case study.

\keywords{BOINC, Cloud, CPDN, Volunteer computing}
\end{abstract}

\introduction
{T}{raditionally}, climate models have been run using supercomputers because of their vast computational complexity and high cost. Since its early development, climate modelling has been an undertaking that has tested the limits of High-Performance Computing (HPC). This application of models to answer different types of questions has led to them being used in manners not originally foreseen. This is because, for some types of  simulations, it can take several months to finish a modelling experiment given the scale of resources involved. One reason for including climate modelling as a High-Throughput Computing (HTC), as opposed to an HPC problem is due to the application design model, where there is a number (not usually greater than twenty) of uncoupled, long-running tasks, each corresponding to a single climate simulation and its results.

The aim of increasing the total number of members in an ensemble of climate simulations, together with the need to achieve increased computational power to better represent the physical and chemical processes being modelled, has been well understood for some decades in meteorological and climate research. Climate models make use of ensemble means to improve the accuracy of the results and quantify uncertainty, but the number of members in each ensemble tends to be small due to computational constraints. The overwhelming majority of research projects use ensembles that generally contain only a very small number of simulations, which has an obvious impact in terms of the statistical uncertainty of the results.


The climate\textit{prediction}.net project (CPDN) was created in 1999~\citep{allen1999,CPDNweb} as a distributed computing initiative to address the uncertainties described above. Its aim is to run thousands of different climate modelling simulations in order to research the uncertainties associated with some of the parameters. This is essential for understanding how small changes or variations in initial conditions can affect both the models themselves and the results of climate simulations. The project is currently run by the University of Oxford using volunteer computing via the BOINC (Berkeley Open Infrastructure for Network Computing) framework~\citep{boinc:Online, anderson2004}. In its early use of distributed computing, CPDN became a precursor of the Many-Task Computing (MTC) paradigm~\citep{raicu2008}.

CPDN has been running for more than 10 years and faces a number of evolving challenges:
\begin{itemize}

\item an  increasing and variable need for new computational and storage resources;
\item the processing power and memory of current volunteers' computers, restricts the use of more complex models and higher resolution.
\item the need to manage costs and budgeting. This is of particular interest in researching on-demand projects requested by external research collaborators and stakeholders;
\end{itemize}

To address these issues we have explored the combination of MTC/volunteer and Cloud computing as a possible improvement or, extension to, a real existing project. This kind of solution has previously been proposed for scientific purposes by~\cite{iosup2011} and is supported by initiatives such as Microsoft Azure for Research~\citep{azure2014}.
\section{Background}
It is not the aim of this paper to describe the internals of BOINC, and for better comprehension of the problem that we are trying to solve,  it is recommended to review previous works about this knowledge such as~\cite{Ries2011}.

\subsection{Problem Description}

Here we describe  some of the problems that we intend to address, as well as proposed implementations of possible solutions:

\begin{itemize}

\item to run more complex and computationally more expensive versions of the model, resources greater than volunteer computers can provide may be needed. One solution is a re-engineering and deployment of the client side from a volunteer computing architecture to an Infrastructure as a Service (IaaS) based on Cloud Computing (e.g. Amazon Web Services, AWS);

\item there is a growing need for an on-demand and more predictable return of simulation results. A good example of this is urgent simulations for critical events in real-time (e.g., floods) where it is not possible to rely on volunteers; instead a widely available and massive scaling system is preferable (like the one described here). The current architecture and infrastructure based on BOINC  does not provide a solution that can be scaled up for this purpose. This is because the models are running over a heterogeneous and decentralized environment (on a number of variable and different volunteersâ€™ computers with varying configurations), where their behaviour cannot be clearly anticipated or measured, and any control over the available resources is severely limited;

%\item a rationalization of the costs is required (and establishing useful metrics), not just for internal control but also to provide monetary quotations to project partners and funding bodies; this led us to the need of the development of a Control Plane using a system composed of a RESTful backend, using Boto to communicate with the AWS API, and SQLite3 (as a local status Database) to control the execution of the simulations, together with a frontend to display the statistics (using HTML5 and the JQuery/jqPlot libraries), information and metrics;
\item a rationalization of the costs is required (and establishing useful metrics), not just for internal control but also to provide monetary quotations to project partners and funding bodies; this led us to the need of the development of a Control Plane together with a frontend to display the statistics information and metrics;

\item use of Free Software in order to promote scientific reproducibility~\citep{anel2011};

\item complete documentation of the process, allowing knowledge to be transferred or migrated easily to other systems~\citep{montes2014}. Additional explanations can be found in the appendices (Appendix A, Appendix B and Appendix C).
\end{itemize}

Furthermore, in this work we wish to prove the feasibility of running complex applications in this environment. We use weather@home~\citep{massey2015}, a high resolution regional climate model nested in a global climate model as an example. The remainder of this paper is organized as follows. We firstly present benchmarks of the weather@home application run in AWS, in section~\ref{section:benchmarks}, then describe the migration of the CPDN infrastructure to AWS in section~\ref{section:cpdn_infrastructure}. We also describe our control plane in section~\ref{section:control_plane} to conduct the simulations and manage the cloud resources. Lastly the results are discussed in the conclusion.

\section{BOINC deployment to the Cloud}

\subsection{Application benchmarks in Amazon Web Services (AWS)}
\label{section:benchmarks}

The example presented here is running CPDN in AWS. AWS is the largest Infrastructure as a Service (IaaS) provider, it is very well documented, as well as being the most suitable solution for the problem at present (and with fewer limitations than other providers).

The first step was to benchmark different AWS EC2 instance types\footnote{https://aws.amazon.com/ec2/instance-types/} to determine their performance running CPDN simulations. These tests were done with a range of instance types, but only choosing instance types that have HMV virtualization available. EBS gp2 storage\footnote{http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html} was used for all instances for ease of comparison. These tests were carried out running multiple copies of a single workunit, in parallel, with the number of simulations matching the number of vCPUs (hyperthreads) available to each instance type. For each instance's types at least 4 tests were run.

For benchmarking purposes, short 1 day climate simulations were run.  The model used here is weather@home2 (atmosphere only model HadAM3P~\citep{gordon2000}, driving the regional version of the same model, HadRM3P~\citep{pope2000}). This version of the model uses the MOSES 2 land surface scheme. The region chosen is at 0.22 degree ($\approx$ 25 km) resolution over Europe.

%Some aspects of the problem were also drafted thanks to these runs: CPU usage was always between 98\% and 100\%, memory usage was residual (average: 1.5\%), GPUs could not be checked for improvement in terms of performance (because they were not supported when our experiments were executed), scratch storage was low, and some parts of the code still ran in 32bit mode.

Figure \ref{fig:plot_time_cost}a shows the average time to run all of the simulations on a particular instance, by instance type. We see a general trend of smaller instances performing better than larger instances. This is likely due to the hardware these instances are on being at a lower load. Running only a single simulation per instance resulted in similar run times for instances of the same category (e.g. c4), and they are not shown in the figure. However, we have verified that it is more cost effective to run the maximum number of simulations per instance than to run instances at a lower load.

Figure \ref{fig:plot_time_cost}b shows the estimated cost of running a one year simulation on each each instance type. The pricing here is based on the Spot Price\footnote{https://aws.amazon.com/ec2/spot/pricing/} in the cheapest availability zone in the us-east-1 region  as of June 2016. This shows that the current generation compute optimized instances (c4) had three out of the four most cost effective choices, but other small instance types are amongst the cheapest. We emphasise that these results are very variable in time and between regions. In the us-west-1 region and us-west-2 regions, the cheapest instance types were m4.large and m4.xlarge respectively, due to the lower spot price for those particular instances in those regions.


\begin{figure}[!h]
\centering
\includegraphics[width=6.5in]{images/plot_time_cost}
\caption{a) Workunit run time and b) Cost per simulation year.}
\label{fig:plot_time_cost}
\end{figure}


\subsection{CPDN infrastructure in AWS}
\label{section:cpdn_infrastructure}

Based on the previous tests, new infrastructure was designed on the cloud (Figure \ref{fig:cloudinfra}). Several steps were required for its implementation, as described below.

\begin{figure}[h!]
\centering
\includegraphics[width=6.5in]{images/cloud_infrastructure}
\caption{Proposed Cloud Infrastructure}
\label{fig:cloudinfra}
\end{figure}


\subsubsection{Computing Infrastructure}
\begin{enumerate}
\item First of all a template was created to allow automated instance creation including:

\begin{itemize}
	%\item instance selection: AWS m1.large;
	\item instance selection, based on the benchmarks presented in section~\ref{section:benchmarks};
	\item base operating system installation: Amazon Linux (64 bit) was used for this work;
	\item storage definition: 16~GB, persistent, standard EBS for this case;
        \item firewall configuration: inbound only SSH(22) accepted, outbound everything accepted;
        \item installation and configuration of BOINC client inside the template image, including its dependencies such as 32 bit libraries. It is recommended to use the latest version from git;%~\citep{git};

\end{itemize}

\item instance contextualization: post installation configuration, for example in AWS this is achieved by creating a machine image (AMI) and adjusting it by selecting the appropriate options such as the Kernel image (AKI);
\item (optional) installation and configuration of AWS EC2 Command Line interface. This can be useful to debug or troubleshoot issues with the infrastructure;


\end{enumerate}

\subsubsection{Storage Infrastructure}
Another problem that needs to be solved is the need for a decentralized, low-latency and world-wide accessible storage for the output data (each simulation (36000 workunits) generates $\sim$656~GB of results). A solution for this could be a distributed (accessed within different and synchronized world-wide endpoints) and scalable massive storage (Figure \ref{fig:storage}). Here we tested an architecture in which the clients send the results (tasks) to an Amazon Simple Storage Service (S3) bucket (storage endpoint). At the same time, CPDN can access these data over the internet to run postprocessing (e.g., a custom assimilator); this can be achieved using the AWS API.

\begin{figure}[!h]
\centering
\includegraphics[width=4.5in]{images/storage_architecture}
\caption{Shared Storage Architecture}
\label{fig:storage}
\end{figure}

Given this values, every workunit returns a result of $\sim$0.018~GB with a price of $\sim$USD0.005414 each ~\citep{S3pricing}, and $\sim$USD194.904 for the full simulation (both storage and data transfer).

\subsection{Project Control Plane}

\label{section:control_plane}

Having set up the computing and storage infrastructure, we still lack a control plane to provide a layer for abstraction and automation, and providing more consistency to the project. The aim of developing the Central Control System (Figure \ref{fig:dashboard_architecture}) is to provide a Cloud-agnostic, easy-to-use frontend (Figure \ref{fig:dashboard}) to manage the experiments with minimal knowledge of the underlying architecture and obtain a real-time overview of the current status (including the resources used and run completion data). Moreover, the Central Control System lends more consistency to the view of the project as an IaaS by providing a simple interface (both backend and frontend).

The Control Plane is still in its early developmental stages (e.g., although it is cloud-agnostic, so far only AWS has a connector and is supported), and further work will describe its improvements over time.

It consists of two main components:

\begin{itemize}
 \item backend: this provides the user with a RESTful API with basic functionalities related to simulation information and management, with the intention of providing (even more) agnostic access to the Cloud;
 \item frontend: this makes it easier to communicate with the API as intuitively and simplistically as possible;
\end{itemize}

 The core component, the RESTful backend (using JSON), provides simple access and wraps common actions: start simulation with n-nodes, stop simulation, modify simulation parameters (n-nodes), get simulation status, and get simulation metrics.


\begin{figure}[!h]
\centering
\includegraphics[width=6.5in]{images/dashboard_architecture}
\caption{Dashboard and metrics application architecture}
\label{fig:dashboard_architecture}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[width=6.5in]{images/screenshots/gui/dashboard01}
\caption{Dashboard}
\label{fig:dashboard}
\end{figure}

\begin{conclusions}
Several experiments (using all the defined infrastructure) were done by using standard workunits developed by the climateprediction.net/weather\@home project. We processed workunits from two main experiments: the weather\@home UK floods~\citep{schaller2016} and the weather\@home Australia New Zealand project~\citep{black2016}, both with an horizontal resolution of 50 km.

It has been successfully demonstrated that it is possible to run simulations of a climatic model using infrastructure in the Cloud; while this might not seem complex, to the best of our knowledge it has never previously been tested. This efficient use of MTC resources for scientific computing has previously been used to facilitate real research in other areas~\citep{anel2014, schaller2014}.

We have benchmarked a number of Amazon EC2 instance types running CPDN workunits. Prices for spot instances vary significantly over time and between instance, but we estimate a price as low as \$1.50 to run a one year simulation based on the c4.large instance in the us-west-1 region in June 2016 (see Figure~\ref{fig:plot_time_cost}). To optimise the costs of running simulations in this environment it will be important to automatically re-evaluate the spot prices to choose the cheapest instance type at the time simulations are submitted. The better performance with smaller instance is due to the fact that vCPUs are hyperthreads and in smaller instance types there is greater chance the CPU is running at a lower utilization and our instances can scavenge extra CPU cycles ~\citep{uhe2016}.

It is interesting to note that Cloud services enable us to achieve a given number of tasks completed in some cases five times faster than using the regular volunteer computing infrastructure. However, the financial implications can only be justified for critical cases where stakeholders are able to jusity through a specific cost benefit analysis. Anyway academic institutions and different type of organizations can benefit from waivers to reduce the fees ~\citep{AWSWaiver}.

About our usage and solution for storage: S3 was a good fit for this work needs, it comes out-of-the box with AWS and the pricing is convenient. However we would not suggest it as suitable long term archival of this output but instead to make use of community repositories where such data is curated (it should be noted though that CPDN produces output in community standard netcdf). Also, we understand that, even though the infrastructure here described cover a good number of use cases for different projects and experiments, other alternatives could be analysed:

\begin{itemize}
 \item AWS Glacier is an interesting option to study in case that long-term, for non-immediate access and with lower-cost, storage for data is needed ~\citep{AWSGlacier}. In our case a full simulation (36000 workunits) would have costed us USD2.624 per month of storage.  
 \item S3 file size is limited to 5TB and this could be a problem for bigger projects so, options like a CephFS cluster on EC2 could be interesting ~\citep{zhao2015}.

\end{itemize}

This research has also served as a basis for obtaining new research funding as part of climateprediction.net for state-of-art studies using Cloud Computing technologies. This project is based on demonstrated successes in the application of technologies and solutions of the type described here.

In summary, the achieved high-level objectives were:
\begin{itemize}
 \item the client side was successfully migrated to the Cloud (EC2);

 \item the upload server capability was configured to be redirected to AWS S3 buckets;

 \item different simulations were successfully run over the new infrastructure;

 \item a Control Plane (including a Dashboard: frontend and backend) was developed, deployed and tested;

 \item a comprehensive costing of the project and the simulation were obtained, together with metrics;
\end{itemize}

Future improvements should focus on providing more logic to the interaction with client status (such as through RPC calls) allowing more metrics to be pulled from them, and creating new Software as a Service (a SaaS layer). From the infrastructure point of view, two main improvements are possible: first, a probe/dummy automated execution will be needed to adjust the price to a real one before each simulation; second, full migration of the server side into the Cloud, allowing the costs of data transfer and latency to be dramatically reduced.

\hfill \break
\end{conclusions}

\authorcontribname. All the authors participated into the design of the experiments and the analysis of results. D. Montes implemented the full infrastructure experiments. P. Uhe carried out the benchmarking. All authors participated in the writing of this paper.

\begin{acknowledgements}
We thank Andy Bowery, Jonathan Miller and Neil R. Massey for all their help and assistance with the internals and specifics of the CPDN BOINC implementation. We also thank the comments by B. N. Lawrence, C. FernÃ¡ndez and A. Arribas that have helped to improve this paper. The compute resources for this project were provided under the AWS Cloud Credits for Research Program.

\end{acknowledgements}

%% REFERENCES

%% The reference list is compiled as follows:

%\begin{thebibliography}{}

%\bibitem[AUTHOR(YEAR)]{LABEL}
%REFERENCE 1

%\bibitem[AUTHOR(YEAR)]{LABEL}
%REFERENCE 2

%\end{thebibliography}

%% Since the Copernicus LaTeX package includes the BibTeX style file copernicus.bst,
%% authors experienced with BibTeX only have to include the following two lines:
%%
\bibliographystyle{copernicus}
\bibliography{1_general.bib}


\appendix
\section{Computing Infrastructure Design and Implementation}

The new computing infrastructure was built over virtualized instances (AWS EC2). Amazon provides also Autoscaling Groups that allow the user to define policies to add or remove dynamically instances triggered by a defined metric or alarm. As the purposes of this work are to use the rationalization of the resources and to have full control over them (via the Central System), as well as any type of Load Balancing or Failover, this feature will not be used in the Cloud side but in the control system node that serves as backend for the Dashboard.

%\noindent The new workflow for a project/model execution is:

%Prerequisites: tasks have been setup in the server side and are ready to be sent to the clients, this can be currently checked into the public URL \url{http://climateapps2.oerc.ox.ac.uk/cpdnboinc/server_status.html}


After tasks have been setup in the server side and are ready to be sent to the clients (this can be currently checked into the public URL
\url{http://climateapps2.oerc.ox.ac.uk/cpdnboinc/server_status.html}), the new workflow for a project/model execution is:

\begin{enumerate}
 \item The (project) administrator user configures and launches a new simulation via the Dashboard.
 \item The required number of instances are created based on a given template that contains a parametrized image of GNU/Linux with a configured BOINC client.
 \item Every instance connects to the server and fetchs 2 tasks (1 per CPU, as the used instances have 2 CPU).
 \item When a task is processed, the data will be returned to the server, and also stored into a Shared Storage so it will be accessible for a given set of authorized users.
 \item Once there are not tasks available, the Control Node will shut down the instances.
\end{enumerate}

It should be noted that, at any point, the administrator will be able to have real time data about the execution (metrics, costs...) as well as change the running
parameters and apply them over the infrastructure.

\subsection{Template Instance Creation}

In order to be able to create an homogeneous infrastructure the first step is to create an (EC2) instance that can be used as template for the other ones.

\begin{table}[h!]
%\begin{center}
\begin{tabular}{|l|l|}
\hline\hline
OS Image (AMI): & Amazon Linux AMI 2014.03.1 (64 bit)\\ \hline
Instance Type: & m1.large\\ \hline
Firewall (Security Groups): & Inbound: Only SSH (22) Accepted\\
\mbox{} & Outbound: Everything Accepted.\\ \hline
Persistent Storage: & Root 16GB (volume type: standard)\\ \hline\hline
\end{tabular}
\caption{Parameter for the template instances}
\label{table:templateInstanceSpecs}
%\end{center}
\end{table}

The high level steps to follow to get a Template Instance (with the parameters defined in the Table~\ref{table:templateInstanceSpecs}) are exposed below:
\begin{enumerate}

\item On the AWS dashboard click ``Launch Instance'', then select the given OS image (AMI) type.
  \begin{center}
  \includegraphics[width=2.5in]{images/screenshots/instance_creation/01.png}\\
  \includegraphics[width=6.5in]{images/screenshots/instance_creation/02.png}
  \end{center}


\item Select the image type .
  \begin{center}
  \includegraphics[width=2.5in]{images/screenshots/instance_creation/03.png}\\
  \includegraphics[width=6.5in]{images/screenshots/instance_creation/04.png}
\end{center}

\item Revise and set the parameters:
\begin{center}
  \includegraphics[width=3.5in]{images/screenshots/instance_creation/05.png}\\
  \includegraphics[width=4.5in]{images/screenshots/instance_creation/06.png}\\
  \includegraphics[width=6.5in]{images/screenshots/instance_creation/07.png}\\
\end{center}

\item Launch the Template Instance.

\end{enumerate}

Note: remember to create a new keypair (public-private key used for passwordless SSH access to the instances) and save it (it will be used for the Central System), or use another one that already exists and is currently accessible. Because of the limited space into this article the line length (new line) has been truncated with $\backslash$, please consider this when running any command described in here.

\subsubsection{Installing and testing AWS and EC2 Command-Line Interface}

(Prerequisites: wget, unzip and Python 2.7.x)

This step is optional, but it is highly recommendable because this will be advanced control of the infrastructure through the shell.
The follow description applies and have been tested on Ubuntu 14.04~\cite{ubuntu}, but can be reproduced into any GNU/Linux system:

First, create an \textit{Access Key} (and secret/password), via the AWS web interface in the \textit{Security Credentials} section. With this data the \textit{AWS\_ACCESS\_KEY} and
\textit{AWS\_SECRET\_KEY} variables should be exported/updated, please have in mind that this mechanism will be also used for the Dashboard/Metrics Application:

\begin{verbatim}
$ echo "export AWS_ACCESS_KEY = \
<your-aws-access-key-id>" \
>> $HOME/.bashrc
$ echo "export AWS_SECRET_KEY = \
<your-aws-secret-key>" \
>> $HOME/.bashrc

$ source $HOME/.bashrc
\end{verbatim}

\begin{verbatim}
#Download and install the AWS CLI
$ wget https://s3.amazonaws.com/\
aws-cli/awscli-bundle.zip &&\
unzip awscli-bundle.zip &&\
sudo ./awscli-bundle/install -i \
/usr/local/aws -b /usr/local/bin/aws

#Download EC2 API tools
wget http://s3.amazonaws.com/\
ec2-downloads/ec2-api-tools.zip &&\

sudo mkdir /usr/local/ec2 &&\
sudo unzip ec2-api-tools.zip -d \
/usr/local/ec2

#Remember to update the
#PATH=$PATH:/usr/local/ec2/\
#ec2-api-tools-<API_VERSION>/bin
$ echo "export JAVA_HOME=/usr/lib/jvm\
/java-6-openjdk-amd64/" >>
$HOME/.bashrc

$ source $HOME/.bashrc
\end{verbatim}

\subsubsection{Installing BOINC and its dependencies}

The project executes both 32 and 64 bits binaries for the simulation so once the Template Instance is running, the needed packages and dependencies need to be installed via:

\begin{verbatim}
$ sudo yum install expat.i686 flac.i686 \
fontconfig.i686 freetype.i686 gamin.i686 \
glib2.i686 glibc.i686gnutls.i686 \
gtk2.i686 libX11.i686 libXau.i686 \
libXext.i686 libXfixes.i686  libXft.i686 \
libXi.i686 libcom_err.i686 libgcc.i686 \
libgcrypt.i686 libgpg-error.i686 \
libstdc++.i686 libxcb.i686 xcb-util.i686 \
zlib.i686 libcurl.i686 openssl097a.i686
\end{verbatim}


The version of BOINC used will be the latest from git~\citep{git}. To download and compile it:

\begin{verbatim}
#Install needed development tools
$ sudo yum groupinstall 'Development Tools'

$ sudo yum install git libcurl \
libcurl-devel openssl097a.i686 \
openssl-devel

#Fetch BOINC source code, compile and
#install the client
$ git clone \
git://boinc.berkeley.edu/boinc-v2.git \
boinc && cd boinc && ./_autosetup \
&& ./configure --disable-server \
--disable-manager --enable-optimize \
&& make \
&& sudo make install

#Create user and set permissions and
#ownership
#(in case that we want a boinc user)
$ sudo adduser boinc
$ sudo chown boinc /var/lib/boinc
\end{verbatim}

Once the BOINC client is installed it must be configured so it will automatically run on every instance
with the same parameters:\\

\begin{enumerate}

 \item  Create a new account in the project:

\begin{verbatim}
$ boinccmd --create_account \
climateprediction.net <EMAIL> \
<PASSWORD> <NAME>
\end{verbatim}


\item With the account created (or if already done) the client needs to be associated to the project by
creating a configuration file with the user token:

\begin{verbatim}
$ boinccmd --lookup_account \
climateprediction.net <EMAIL> \
<PASSWORD>| grep "account key" \
| sed 's/\(.*\): \(.*\)/\2/g' \
| xargs boinccmd --project_attach \
climateprediction.net

#Status check
$ boinccmd --get_state
\end{verbatim}

\item Make BOINC to start with the system (ec2-user will be used because of permissions):

\begin{verbatim}
$sudo echo 'su - ec2-user -c \
"cd /home/ec2-user/boinc-client/\
bin/ && ./boinc --daemon"'\
>> /etc/rc.local
\end{verbatim}

\end{enumerate}

\subsubsection{Simulation Terminator}

An essential piece of software, developed for this work, is the \textit{Simulation Terminator}, that decides if a node should shutdown itself in case that workunits were not processed for a given amount of time (by default 6 hours, via cron) or there are no jobs waiting on the server.

This application will be provided upon request to the authors.


To install it (by default into \textit{/opt/climateprediction/} ):

\begin{verbatim}
$ sudo ./installClient
>> Simulation Client succesfully installed!
\end{verbatim}

When an instance is powered off, it will be terminated (destroyed) by the \textit{Reaper} service, that runs into the Central Control System.


\subsection{Contextualization}

Now that the Template Instance is ready, this is that all the parameters have been configured and the BOINC client is ready to start processing tasks, the next stage is to contextualize it. This means that a OS image will be created from it, which will give our infrastructure the capacity of being scalable by creating new instances from this new image. Unfortunately this part is strongly related with the Cloud type, and although can be replicated into another systems, by now it will only explicitly work in this way for AWS.

The steps to follow:
\begin{enumerate}
 \item On the instances list (AWS Dashboard), select the Template Instance, right click and select \textit{Create Image},
 name of the image: \textit{CLIMATE\_PREDICTION\_TEMPLATE}. This will create a disk Image that can be used for a full Instance Template (AMI):
\begin{center}
  \includegraphics[width=4.5in]{images/screenshots/image_creation/01.png} \\
  \includegraphics[width=6.5in]{images/screenshots/image_creation/02.png}
\end{center}

\item To finally create the Instance Image (in the AWS Dashboard) go to Ima\-ges$\rightarrow$AMIs and right click on \textit{CLIMATE\_PREDIC\-TION\_TEMPLATE}
 and fill the parameters, at least name as \textit{CLIMATE\_PREDICTION\_TEMPLATE} (the same as Image, for better identification) and match the kernel image (AKI) with the original
 Template Instance (currently: aki-919dcaf8). This step is very important, otherwise the new instances created for the project simulations
 won't boot correctly.
\begin{center}
  \includegraphics[width=4.5in]{images/screenshots/image_creation/03.png}\\
  \includegraphics[width=6.5in]{images/screenshots/image_creation/04.png}
\end{center}
\end{enumerate}

At this point the Computing infrastructure is ready to be deployed and scaled, this will be done trough the Dashboard.


\section{Upload Server}

Once a client has processed a workunit, the task (result) is created and sent to the defined Upload Server, that for the CPDN is \url{http://cpdn-upload2.oerc.ox.ac.uk/cpdn_cgi/file_upload_handler}. This needs to be done in a transparent way for the clients and without modifying the server because we don't want to affect the actual running experiments (but in the future the servers should distribute a configuration that directly points to the S3 bucket). To do this the data should be intercepted, and this can be done in 2 steps/components:


\begin{itemize}
 \item \textbf{The name resolution} should be \textit{faked} by changing the CNAME \url{http://cpdn-upload2.oerc.ox.ac.uk/cpdn_cgi/file_upload_handler} point to the created S3 bucket endpoint. Bind documentation can be reviewed for this in~\cite{bind2010}

\item \textbf{A web server as endpoint}, with HTTP and HTTPs support, configured to resolve the URL \url{http://$UPLOAD_SERVER/cpdn_cgi/} (the jobs are created to target this URL). To simplify this stage, the storage provided by AWS, S3, will be used because it has a simple HTTP(s) server that supports all the required HTTP methods (GET and POST). The (expected) content of the \textit{file\_upload\_handler} must be:

\begin{verbatim}
<data_server_reply>
    <status>1</status>
</data_server_reply>
\end{verbatim}

\begin{enumerate}
\item Access to the S3 Service from the AWS dashboard.
\begin{center}
  \includegraphics[width=2.1in]{images/screenshots/storage/storage01.png}
\end{center}

\item Click on "Create" Bucket, the name should be \textit{CLIMATE\_PREDICTION} and must be in the same Region than the instances.
\begin{center}
  \includegraphics[width=4.5in]{images/screenshots/storage/storage02.png}
\end{center}

\item Activate (in the Options) the HTTP/HTTPs server.
\begin{center}
  \includegraphics[width=4.5in]{images/screenshots/storage/storage03.png}\\
  \includegraphics[width=4.5in]{images/screenshots/storage/storage04.png}
\end{center}

\item To secure the bucket remember to modify the policy so only allowed IP ranges can access it (in this case only IP ranges from instances and from CPND servers).


\begin{verbatim}
{
 "Version": "2012-10-17",
 "Id": "S3PolicyId1",
  "Statement": [
    {
    "Sid": "IPAllow",
    "Effect": "Allow",
    "Principal": "*",
    "Action": "s3:*",
    "Resource":
      "arn:aws:s3:::CLIMATE_PREDICTION/*",

    "Condition" : {
     "IpAddress" : {
       "aws:SourceIp": "ALLOWED_IP_RANGES"
                   }
                  }
    } ]
}
\end{verbatim}
\end{enumerate}
\end{itemize}


\section{Central Control System and Dashboard}

\subsection{Backend and API}
The backend of the Central System consists into:
\begin{itemize}

\item a \textit{RESTful (Representational state transfer) API} over Flask (a Python web microframework~\citep{Flask:2013:Online}) that controls the Infrastructure (with Boto, a Python interface to Amazon Web Services \citep{Boto:2010:Online}).

\item A \textit{Simple Scheduler}, that will be in the background and will take care that the simulation is running with the given parameters (e.g.\ all the required instances are up).

\item The \textit{Reaper}, a subsystem of the Simple Scheduler that is some sort of garbage collector and will terminate powered off instances in order to release resources.
\end{itemize}

\subsubsection{API Reference}
The backend can be reused and integrated into another systems in order to give the full abstraction over the project. The available requests (HTTP) are:

\begin{itemize}
 \item \textbf{Get Simulation Status:}\\
 Call: \textit{status}\\
 Request Type \textit{GET}\\
 Returns: \textit{JSON} object with current simulation status:
\begin{verbatim}
{
 requestedInstances:
  <int:REQUESTED_INSTANCES>

 executionCost:
  <float:EXECUTION_COST_IN_USD>,

 workunitCost:
  <float:WORKUNIT_COST_IN_USD>,
}
\end{verbatim}


 \item \textbf{Get Metric:}\\
 Call: \textit{metric/METRICNAME}\\
 Request Type \textit{GET}\\
 Returns: \textit{JSON} object with metric (time series):
\begin{verbatim}
{
 <METRIC_VARIABLE>:
  [{<int|float:METRIC_DATA>,
    <timestamp:TIMESTAMP>}],
}
\end{verbatim}

 \item \textbf{Set/Modify Simulation:}\\
 Call: \textit{simulation}\\
 Request Type \textit{POST}\\
 Input: \textit{JSON} object with simulation parameters, if already running will modify it:\\
 Returns: \textit{JSON} object with result (0=fail, 1=succesful):
\begin{verbatim}
{
 instances: <int:REQUESTED_INSTANCES>
}
\end{verbatim}

\begin{verbatim}
{
 result: <0|1>
}
\end{verbatim}

 \item \textbf{Stop Simulation:}\\
 Call: \textit{simulation/stop}\\
 Request Type \textit{GET}\\
 Returns: \textit{JSON} object with result (0=fail, 1=succesful):
\begin{verbatim}
{
 result: <0|1>
}
\end{verbatim}
\end{itemize}

A simplistic (but functional) GUI (Graphical User Interface) has been designed to make it more understandable the execution of the simulation on the Cloud.

Two control actions are available:

\begin{itemize}
	\item Start/Edit Simulation: sets the parameters (cloud type, number of instances...) of the simulation and runs it.
    \item Stop Simulation: forces all the instances to Terminate.
\end{itemize}

There are 3 default metrics (default time lapse: 6 hours):

\begin{itemize}
  \item Active Instances: number of Active Instances.
  \item Completed Tasks: number of workunits successfully completed.
  \item Simulation Cost: accumulated Cost for the Simulation.
\end{itemize}

\subsection{Installation and Configuration}

The applications are intended to run at any GNU/Linux The only requirements are (apart from Python 2.7) Flask and Boto, that can be easily installed into any GNU/Linux :

\begin{verbatim}
$ pip install flask virtualenv \
  boto pysqlite daemonize
\end{verbatim}

\subsubsection{First configuration and Run}

For this step the file \texttt{controlSystem.tar.gz}, which contains all the software and configurations for the Central System, needs to be uncompressed into /opt/climateprediction/, then just:


\begin{verbatim}
$ cd /opt/climateprediction
$ ./firstRun.py
>> Connector Type? aws
>> AWS Key: \
   <TYPE_YOUR_AWS_KEY>
>> AWS Secret: \
   <TYPE_YOUR_AWS_KEY_SECRET>

>> Dashboard Username: \
   <TYPE_DASHBOARD_USERNAME>
>> Dashboard Password: \
   <TYPE_DASHBOARD_PASSWORD>

[OK] Central System Ready to Run!
     Type ./run.py to start.

#Start the service...
$ ./run.py

#... and Central System starts
#resolving backend and frontend requests
\end{verbatim}

Optionally the configuration can be set manually by editing the file \textit{Config.cfg} (parameters in <>):

\begin{verbatim}
#Main Configuration
[main]
connector=<CLOUD_CONNECTOR>
pollingTime=<REFRESH_TIME_IN_SECONDS>

[HTTPAuth]
user=<DASHBOARD_USERNAME>
password=<DASHBOARD_PASSWORD>

#AWS Credentials Configuration
[AWSCredentials]
KEY=<AWS_KEY>
PASSWORD=<AWS_SECRET>

#AWS Connector Configuration
[AWS]
AMI=<AMI>
instanceType=<INSTANCE_TYPE>
securityGroup=CLIMATE_PREDICTION
keyPair=<CLIMATE_PREDICTION_KEYPAIR>
\end{verbatim}

\subsection{Use and Project Deployment}
Now that the Central System has been installed and configured, it will be listening and accepting connections into any network interface (0.0.0.0) on port 5000, protocol HTTP, so it can be accesed via web browser. Firefox or Chromium are recommended because of Javascript compatibility.

\subsubsection{Launch a New Simulation}
When starting a simulation the number of instances will be 0. This can be changed by clicking ``Edit Simulation'', set the number into the input box and click on \textit{Apply Changes}. Within some minutes (defined in the configuration file, in the \textit{pollingTime} variable) the system will start to deploy instances (workers).
\begin{center}
  \includegraphics[width=1.1in]{images/screenshots/simulation/simulation01.png} \\
  \includegraphics[width=2.5in]{images/screenshots/simulation/simulation02.png}
\end{center}


\subsubsection{Modify a Simulation}
If the number of instances needs to be adjusted when a simulation is running the procedure is the same than launching a new simulation (\textit{Edit Simulation}). \textbf{Please be aware that if the number of instances is reduced unfinished workunits will be lost} (the scheduler will stop and terminate them using a FIFO).

\subsubsection{End Current Simulation}
When a simulation wants to be stopped click \textit{Stop Simulation}. This will reduce the number of instances to 0, copy the database as \textit{SIMULATION-TIMESTAMP} for further analysis and reset all the parameters and metrics.
\begin{center}
  \includegraphics[width=1.1in]{images/screenshots/simulation/simulation03.png}
\end{center}

%%
%% URLs and DOIs can be entered in your BibTeX file as:
%%
%% URL = {http://www.xyz.org/~jones/idx_g.htm}
%% DOI = {10.5194/xyz}


%% LITERATURE CITATIONS
%%
%% command                        & example result
%% \citet{jones90}|               & Jones et al. (1990)
%% \citep{jones90}|               & (Jones et al., 1990)
%% \citep{jones90,jones93}|       & (Jones et al., 1990, 1993)
%% \citep[p.~32]{jones90}|        & (Jones et al., 1990, p.~32)
%% \citep[e.g.,][]{jones90}|      & (e.g., Jones et al., 1990)
%% \citep[e.g.,][p.~32]{jones90}| & (e.g., Jones et al., 1990, p.~32)
%% \citeauthor{jones90}|          & Jones et al.
%% \citeyear{jones90}|            & 1990



%% FIGURES

%% ONE-COLUMN FIGURES

%%f
%\begin{figure}[t]
%\includegraphics[width=8.3cm]{FILE NAME}
%\caption{TEXT}
%\end{figure}
%
%%% TWO-COLUMN FIGURES
%
%%f
%\begin{figure*}[t]
%\includegraphics[width=12cm]{FILE NAME}
%\caption{TEXT}
%\end{figure*}
%
%
%%% TABLES
%%%
%%% The different columns must be seperated with a & command and should
%%% end with \\ to identify the column brake.
%
%%% ONE-COLUMN TABLE
%
%%t
%\begin{table}[t]
%\caption{TEXT}
%\begin{tabular}{column = lcr}
%\tophline
%
%\middlehline
%
%\bottomhline
%\end{tabular}
%\belowtable{} % Table Footnotes
%\end{table}
%
%%% TWO-COLUMN TABLE
%
%%t
%\begin{table*}[t]
%\caption{TEXT}
%\begin{tabular}{column = lcr}
%\tophline
%
%\middlehline
%
%\bottomhline
%\end{tabular}
%\belowtable{} % Table Footnotes
%\end{table*}
%
%
%%% NUMBERING OF FIGURES AND TABLES
%%%
%%% If figures and tables must be numbered 1a, 1b, etc. the following command
%%% should be inserted before the begin{} command.
%
%\addtocounter{figure}{-1}\renewcommand{\thefigure}{\arabic{figure}a}
%
%
%%% MATHEMATICAL EXPRESSIONS
%
%%% All papers typeset by Copernicus Publications follow the math typesetting regulations
%%% given by the IUPAC Green Book (IUPAC: Quantities, Units and Symbols in Physical Chemistry,
%%% 2nd Edn., Blackwell Science, available at: http://old.iupac.org/publications/books/gbook/green_book_2ed.pdf, 1993).
%%%
%%% Physical quantities/variables are typeset in italic font (t for time, T for Temperature)
%%% Indices which are not defined are typeset in italic font (x, y, z, a, b, c)
%%% Items/objects which are defined are typeset in roman font (Car A, Car B)
%%% Descriptions/specifications which are defined by itself are typeset in roman font (abs, rel, ref, tot, net, ice)
%%% Abbreviations from 2 letters are typeset in roman font (RH, LAI)
%%% Vectors are identified in bold italic font using \vec{x}
%%% Matrices are identified in bold roman font
%%% Multiplication signs are typeset using the LaTeX commands \times (for vector products, grids, and exponential notations) or \cdot
%%% The character * should not be applied as mutliplication sign
%
%
%%% EQUATIONS
%
%%% Single-row equation
%
%\begin{equation}
%
%\end{equation}
%
%%% Multiline equation
%
%\begin{align}
%& 3 + 5 = 8\\
%& 3 + 5 = 8\\
%& 3 + 5 = 8
%\end{align}
%
%
%%% MATRICES
%
%\begin{matrix}
%x & y & z\\
%x & y & z\\
%x & y & z\\
%\end{matrix}
%
%
%%% ALGORITHM
%
%\begin{algorithm}
%\caption{ï¿½}
%\label{a1}
%\begin{algorithmic}
%ï¿½
%\end{algorithmic}
%\end{algorithm}
%
%
%%% CHEMICAL FORMULAS AND REACTIONS
%
%% For formulas embedded in the text, please use \chem{}
%
%%% The reaction environment creates labels including the letter R, i.e. (R1), (R2), etc.
%
%\begin{reaction}
%%% \rightarrow should be used for normal (one-way) chemical reactions
%%% \rightleftharpoons should be used for equilibria
%%% \leftrightarrow should be used for resonance structures
%\end{reaction}
%
%
%%% PHYSICAL UNITS
%%%
%%% Please use \unit{} and apply the exponential notation


\end{document}
